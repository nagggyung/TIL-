### Web 개발을 한다는 것은 크게 3가지 방법이 있다.
- 정적 컨텐츠
- MVC와 템플릿 엔진
- API

### 1) 정적 컨텐츠
- resources/static/hello-static.html

```c
<!DOCTYPE HTML>
<html>
<head>
    <title>static content</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
</head>
<body>
정적 컨텐츠 입니다.
</body>
</html>
```
- 실행: http://localhost:8080/hello-static.html
- 정적 컨텐츠 방식이란, 파일을 웹브라우져에 그대로 내려주는 방식을 의미한다. 
- 정적 컨텐츠 작동 원리:

![2021-09-20 (2)](https://user-images.githubusercontent.com/74478432/133996157-be28cf50-cd13-40d2-9c58-a63d16a173b9.png)

* 웹 부라우져에서 localhost:8080/hello-static.html 입력
* 내장 톰켓 서버가 요청을 받아 스프링 부트에게 전달 
* 스프링은 Controller에서 hello-static이 있는지 검색 (즉, Controller가 우선순위를 먼저 갖는다.)
* hello-static 관련 컨트롤러가 없으므로, resource 폴더에서 hello-static.html 검색 
* 브라우져에 html 파일을 Rendering  


### 2) MVC와 템플릿 엔진
* MVC: Model, View, Controller

- Controller 

```c
@Controller
public class HelloController {
    @GetMapping("hello-mvc")
    public String helloMvc(@RequestParam("name") String name, Model model){  
    // @ReuqestParam : url에서 받은 데이터 ?name=value
        model.addAttribute("name",name);
        return "hello-template";
    // templates 폴더에서 'hello-template.html' 검색 
    // model(name) 이 template(view)로 넘어감 
    }
}
```

- View: resources/template/hello-template.html

```c
<html xmlns:th="http://www.thymeleaf.org">
<body>
<p th:text="'hello ' + ${name}"> hello! empty</p>
// $ 표시 : model의 key 가 name 인 것의 value를 참조한다.
// th = thymeleaf
// 실제 서버 구동해서 타임리프엔진을 통해 데이터가 생기면, 태그 안에 있는 hello! empty가 치환
</body>
</html>
```

- 실행: http://localhost:8080/hello-mvc?name=spring ('?' 를 이용하여 parameter을 넘겨줄 수 있다.)
- MVC, 템플릿 엔진 작동 원리:

![2021-09-20 (3)](https://user-images.githubusercontent.com/74478432/133998084-0cdb0e1a-bcf6-4f57-a8f3-5bd70a0b0630.png)

* 브라우저에서 localhost:8080/hello-mvc?name=spring!
* 내장 톰켓 서버가 url을 스프링에 전달
* 매핑된 컨트롤러에게 전달
* 모델에 데이터를 처리한 뒤, 템플릿 이름을 return
* viewResolver은 해당하는 템플릿을 찾아 템플릿 엔진인 타임리프에게 전달
* html 형식으로 변환된 값을 브라우저에게 리턴 (정적 컨텐츠 일때는 html로 변환하는 과정이 없다.)


### 3) API

- @ResponseBody 문자 반환

```c
@Controller
public class HelloController {
    @GetMapping("hello-string") //url: hello-string 이 들어오면 아래 함수 실행
    @ResponseBody // http 통신 프로토콜에서 body 데이터를 직접 넣어주겠다고 선언
    public String helloString(@RequestParam("name") String name){
        return "hello " + name;
    }
 }
```

* @ResponseBody를 사용하면 viewResolver를 사용하지 않음
* 대신에 HTTP의 BODY에 문자 내용을 직접 반환 

- 실행: http://localhost:8080/hello-string?name=spring
- @ResponseBody 객체 반환
```c
@Controller
public class HelloController {
    @GetMapping("hello-api")
    @ResponseBody
    public Hello helloApi(@RequestParam("name") String name){
        Hello hello = new Hello();
        hello.setName(name);
        return hello; // 객체 반환
    }

    static class Hello {
        private String name;

        public String getName(){
            return name;
        }

        public void setName(String name){
            this.name = name;
        }
    }
 }
```
* @ResponseBody를 사용하고, 객체를 반환하면 객체가 JSON으로 변환됨

- 실행: http://localhost:8080/hello-api?name=spring
- @ResponseBody 사용 원리:

![2021-09-20 (4)](https://user-images.githubusercontent.com/74478432/134000982-551da9ab-b16e-42fd-83ca-544ce0680e26.png)

* @ResponseBody 사용
   * HTTP의 BODY에 문자 내용을 직접 반환
   * viewResolver 대신에 HttpMessageConverter 가 동작
   * 기본 문자 처리: StringHttpMessageConverter
   * 기본 객체 처리: MappingJackson2HttpMessageConverter
   * byte 처리 등등 기타 여러 HttpMessageConverter가 기본으로 등록되어 있음
   * 객체는 JSON 방식으로 반환(Default)
  
  
